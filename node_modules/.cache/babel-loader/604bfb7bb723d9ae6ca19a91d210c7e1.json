{"ast":null,"code":"'use strict'; //Const\n\nvar _classCallCheck = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/web.dom-collections.iterator.js\");\n\nrequire(\"core-js/modules/es.object.create.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nvar NOAH_ARK_CAPACITY = 3; //List of formatting elements\n\nvar FormattingElementList = /*#__PURE__*/function () {\n  function FormattingElementList(treeAdapter) {\n    _classCallCheck(this, FormattingElementList);\n\n    this.length = 0;\n    this.entries = [];\n    this.treeAdapter = treeAdapter;\n    this.bookmark = null;\n  } //Noah Ark's condition\n  //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n  //lightweight heuristics without thorough attributes check.\n\n\n  _createClass(FormattingElementList, [{\n    key: \"_getNoahArkConditionCandidates\",\n    value: function _getNoahArkConditionCandidates(newElement) {\n      var candidates = [];\n\n      if (this.length >= NOAH_ARK_CAPACITY) {\n        var neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n        var neTagName = this.treeAdapter.getTagName(newElement);\n        var neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n        for (var i = this.length - 1; i >= 0; i--) {\n          var entry = this.entries[i];\n\n          if (entry.type === FormattingElementList.MARKER_ENTRY) {\n            break;\n          }\n\n          var element = entry.element;\n          var elementAttrs = this.treeAdapter.getAttrList(element);\n          var isCandidate = this.treeAdapter.getTagName(element) === neTagName && this.treeAdapter.getNamespaceURI(element) === neNamespaceURI && elementAttrs.length === neAttrsLength;\n\n          if (isCandidate) {\n            candidates.push({\n              idx: i,\n              attrs: elementAttrs\n            });\n          }\n        }\n      }\n\n      return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n  }, {\n    key: \"_ensureNoahArkCondition\",\n    value: function _ensureNoahArkCondition(newElement) {\n      var candidates = this._getNoahArkConditionCandidates(newElement);\n\n      var cLength = candidates.length;\n\n      if (cLength) {\n        var neAttrs = this.treeAdapter.getAttrList(newElement);\n        var neAttrsLength = neAttrs.length;\n        var neAttrsMap = Object.create(null); //NOTE: build attrs map for the new element so we can perform fast lookups\n\n        for (var i = 0; i < neAttrsLength; i++) {\n          var neAttr = neAttrs[i];\n          neAttrsMap[neAttr.name] = neAttr.value;\n        }\n\n        for (var _i = 0; _i < neAttrsLength; _i++) {\n          for (var j = 0; j < cLength; j++) {\n            var cAttr = candidates[j].attrs[_i];\n\n            if (neAttrsMap[cAttr.name] !== cAttr.value) {\n              candidates.splice(j, 1);\n              cLength--;\n            }\n\n            if (candidates.length < NOAH_ARK_CAPACITY) {\n              return;\n            }\n          }\n        } //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n\n\n        for (var _i2 = cLength - 1; _i2 >= NOAH_ARK_CAPACITY - 1; _i2--) {\n          this.entries.splice(candidates[_i2].idx, 1);\n          this.length--;\n        }\n      }\n    } //Mutations\n\n  }, {\n    key: \"insertMarker\",\n    value: function insertMarker() {\n      this.entries.push({\n        type: FormattingElementList.MARKER_ENTRY\n      });\n      this.length++;\n    }\n  }, {\n    key: \"pushElement\",\n    value: function pushElement(element, token) {\n      this._ensureNoahArkCondition(element);\n\n      this.entries.push({\n        type: FormattingElementList.ELEMENT_ENTRY,\n        element: element,\n        token: token\n      });\n      this.length++;\n    }\n  }, {\n    key: \"insertElementAfterBookmark\",\n    value: function insertElementAfterBookmark(element, token) {\n      var bookmarkIdx = this.length - 1;\n\n      for (; bookmarkIdx >= 0; bookmarkIdx--) {\n        if (this.entries[bookmarkIdx] === this.bookmark) {\n          break;\n        }\n      }\n\n      this.entries.splice(bookmarkIdx + 1, 0, {\n        type: FormattingElementList.ELEMENT_ENTRY,\n        element: element,\n        token: token\n      });\n      this.length++;\n    }\n  }, {\n    key: \"removeEntry\",\n    value: function removeEntry(entry) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        if (this.entries[i] === entry) {\n          this.entries.splice(i, 1);\n          this.length--;\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"clearToLastMarker\",\n    value: function clearToLastMarker() {\n      while (this.length) {\n        var entry = this.entries.pop();\n        this.length--;\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          break;\n        }\n      }\n    } //Search\n\n  }, {\n    key: \"getElementEntryInScopeWithTagName\",\n    value: function getElementEntryInScopeWithTagName(tagName) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var entry = this.entries[i];\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY) {\n          return null;\n        }\n\n        if (this.treeAdapter.getTagName(entry.element) === tagName) {\n          return entry;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getElementEntry\",\n    value: function getElementEntry(element) {\n      for (var i = this.length - 1; i >= 0; i--) {\n        var entry = this.entries[i];\n\n        if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n          return entry;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return FormattingElementList;\n}(); //Entry types\n\n\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\nmodule.exports = FormattingElementList;","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/cheerio/node_modules/parse5/lib/parser/formatting-element-list.js"],"names":["NOAH_ARK_CAPACITY","FormattingElementList","treeAdapter","length","entries","bookmark","newElement","candidates","neAttrsLength","getAttrList","neTagName","getTagName","neNamespaceURI","getNamespaceURI","i","entry","type","MARKER_ENTRY","element","elementAttrs","isCandidate","push","idx","attrs","_getNoahArkConditionCandidates","cLength","neAttrs","neAttrsMap","Object","create","neAttr","name","value","j","cAttr","splice","token","_ensureNoahArkCondition","ELEMENT_ENTRY","bookmarkIdx","pop","tagName","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n//Const\nconst NOAH_ARK_CAPACITY = 3;\n\n//List of formatting elements\nclass FormattingElementList {\n    constructor(treeAdapter) {\n        this.length = 0;\n        this.entries = [];\n        this.treeAdapter = treeAdapter;\n        this.bookmark = null;\n    }\n\n    //Noah Ark's condition\n    //OPTIMIZATION: at first we try to find possible candidates for exclusion using\n    //lightweight heuristics without thorough attributes check.\n    _getNoahArkConditionCandidates(newElement) {\n        const candidates = [];\n\n        if (this.length >= NOAH_ARK_CAPACITY) {\n            const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;\n            const neTagName = this.treeAdapter.getTagName(newElement);\n            const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);\n\n            for (let i = this.length - 1; i >= 0; i--) {\n                const entry = this.entries[i];\n\n                if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                    break;\n                }\n\n                const element = entry.element;\n                const elementAttrs = this.treeAdapter.getAttrList(element);\n\n                const isCandidate =\n                    this.treeAdapter.getTagName(element) === neTagName &&\n                    this.treeAdapter.getNamespaceURI(element) === neNamespaceURI &&\n                    elementAttrs.length === neAttrsLength;\n\n                if (isCandidate) {\n                    candidates.push({ idx: i, attrs: elementAttrs });\n                }\n            }\n        }\n\n        return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;\n    }\n\n    _ensureNoahArkCondition(newElement) {\n        const candidates = this._getNoahArkConditionCandidates(newElement);\n        let cLength = candidates.length;\n\n        if (cLength) {\n            const neAttrs = this.treeAdapter.getAttrList(newElement);\n            const neAttrsLength = neAttrs.length;\n            const neAttrsMap = Object.create(null);\n\n            //NOTE: build attrs map for the new element so we can perform fast lookups\n            for (let i = 0; i < neAttrsLength; i++) {\n                const neAttr = neAttrs[i];\n\n                neAttrsMap[neAttr.name] = neAttr.value;\n            }\n\n            for (let i = 0; i < neAttrsLength; i++) {\n                for (let j = 0; j < cLength; j++) {\n                    const cAttr = candidates[j].attrs[i];\n\n                    if (neAttrsMap[cAttr.name] !== cAttr.value) {\n                        candidates.splice(j, 1);\n                        cLength--;\n                    }\n\n                    if (candidates.length < NOAH_ARK_CAPACITY) {\n                        return;\n                    }\n                }\n            }\n\n            //NOTE: remove bottommost candidates until Noah's Ark condition will not be met\n            for (let i = cLength - 1; i >= NOAH_ARK_CAPACITY - 1; i--) {\n                this.entries.splice(candidates[i].idx, 1);\n                this.length--;\n            }\n        }\n    }\n\n    //Mutations\n    insertMarker() {\n        this.entries.push({ type: FormattingElementList.MARKER_ENTRY });\n        this.length++;\n    }\n\n    pushElement(element, token) {\n        this._ensureNoahArkCondition(element);\n\n        this.entries.push({\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    insertElementAfterBookmark(element, token) {\n        let bookmarkIdx = this.length - 1;\n\n        for (; bookmarkIdx >= 0; bookmarkIdx--) {\n            if (this.entries[bookmarkIdx] === this.bookmark) {\n                break;\n            }\n        }\n\n        this.entries.splice(bookmarkIdx + 1, 0, {\n            type: FormattingElementList.ELEMENT_ENTRY,\n            element: element,\n            token: token\n        });\n\n        this.length++;\n    }\n\n    removeEntry(entry) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            if (this.entries[i] === entry) {\n                this.entries.splice(i, 1);\n                this.length--;\n                break;\n            }\n        }\n    }\n\n    clearToLastMarker() {\n        while (this.length) {\n            const entry = this.entries.pop();\n\n            this.length--;\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                break;\n            }\n        }\n    }\n\n    //Search\n    getElementEntryInScopeWithTagName(tagName) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.MARKER_ENTRY) {\n                return null;\n            }\n\n            if (this.treeAdapter.getTagName(entry.element) === tagName) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n\n    getElementEntry(element) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const entry = this.entries[i];\n\n            if (entry.type === FormattingElementList.ELEMENT_ENTRY && entry.element === element) {\n                return entry;\n            }\n        }\n\n        return null;\n    }\n}\n\n//Entry types\nFormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';\nFormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';\n\nmodule.exports = FormattingElementList;\n"]},"metadata":{},"sourceType":"script"}