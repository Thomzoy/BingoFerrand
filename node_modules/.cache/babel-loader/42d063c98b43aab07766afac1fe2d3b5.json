{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.function.name.js\");\n\nrequire(\"core-js/modules/es.array.is-array.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\n/*\n * Pseudo selectors\n *\n * Pseudo selectors are available in three forms:\n *\n * 1. Filters are called when the selector is compiled and return a function\n *  that has to return either false, or the results of `next()`.\n * 2. Pseudos are called on execution. They have to return a boolean.\n * 3. Subselects work like filters, but have an embedded selector that will be run separately.\n *\n * Filters are great if you want to do some pre-processing, or change the call order\n * of `next()` and your code.\n * Pseudos should be used to implement simple checks.\n */\n\nvar boolbase_1 = require(\"boolbase\");\n\nvar css_what_1 = require(\"css-what\");\n\nvar filters_1 = require(\"./filters\");\n\nObject.defineProperty(exports, \"filters\", {\n  enumerable: true,\n  get: function get() {\n    return filters_1.filters;\n  }\n});\n\nvar pseudos_1 = require(\"./pseudos\");\n\nObject.defineProperty(exports, \"pseudos\", {\n  enumerable: true,\n  get: function get() {\n    return pseudos_1.pseudos;\n  }\n});\n\nvar aliases_1 = require(\"./aliases\");\n\nObject.defineProperty(exports, \"aliases\", {\n  enumerable: true,\n  get: function get() {\n    return aliases_1.aliases;\n  }\n});\n\nvar subselects_1 = require(\"./subselects\");\n\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\n  var name = selector.name,\n      data = selector.data;\n\n  if (Array.isArray(data)) {\n    return subselects_1.subselects[name](next, data, options, context, compileToken);\n  }\n\n  if (name in aliases_1.aliases) {\n    if (data != null) {\n      throw new Error(\"Pseudo \".concat(name, \" doesn't have any arguments\"));\n    } // The alias has to be parsed here, to make sure options are respected.\n\n\n    var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);\n    return subselects_1.subselects.is(next, alias, options, context, compileToken);\n  }\n\n  if (name in filters_1.filters) {\n    return filters_1.filters[name](next, data, options, context);\n  }\n\n  if (name in pseudos_1.pseudos) {\n    var pseudo_1 = pseudos_1.pseudos[name];\n    (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);\n    return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function (elem) {\n      return pseudo_1(elem, options, data);\n    } : function (elem) {\n      return pseudo_1(elem, options, data) && next(elem);\n    };\n  }\n\n  throw new Error(\"unmatched pseudo-class :\".concat(name));\n}\n\nexports.compilePseudoSelector = compilePseudoSelector;","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/css-select/lib/pseudo-selectors/index.js"],"names":["Object","defineProperty","exports","value","compilePseudoSelector","aliases","pseudos","filters","boolbase_1","require","css_what_1","filters_1","enumerable","get","pseudos_1","aliases_1","subselects_1","next","selector","options","context","compileToken","name","data","Array","isArray","subselects","Error","concat","alias","parse","is","pseudo_1","verifyPseudoArgs","falseFunc","trueFunc","elem"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compilePseudoSelector = exports.aliases = exports.pseudos = exports.filters = void 0;\n/*\n * Pseudo selectors\n *\n * Pseudo selectors are available in three forms:\n *\n * 1. Filters are called when the selector is compiled and return a function\n *  that has to return either false, or the results of `next()`.\n * 2. Pseudos are called on execution. They have to return a boolean.\n * 3. Subselects work like filters, but have an embedded selector that will be run separately.\n *\n * Filters are great if you want to do some pre-processing, or change the call order\n * of `next()` and your code.\n * Pseudos should be used to implement simple checks.\n */\nvar boolbase_1 = require(\"boolbase\");\nvar css_what_1 = require(\"css-what\");\nvar filters_1 = require(\"./filters\");\nObject.defineProperty(exports, \"filters\", { enumerable: true, get: function () { return filters_1.filters; } });\nvar pseudos_1 = require(\"./pseudos\");\nObject.defineProperty(exports, \"pseudos\", { enumerable: true, get: function () { return pseudos_1.pseudos; } });\nvar aliases_1 = require(\"./aliases\");\nObject.defineProperty(exports, \"aliases\", { enumerable: true, get: function () { return aliases_1.aliases; } });\nvar subselects_1 = require(\"./subselects\");\nfunction compilePseudoSelector(next, selector, options, context, compileToken) {\n    var name = selector.name, data = selector.data;\n    if (Array.isArray(data)) {\n        return subselects_1.subselects[name](next, data, options, context, compileToken);\n    }\n    if (name in aliases_1.aliases) {\n        if (data != null) {\n            throw new Error(\"Pseudo \".concat(name, \" doesn't have any arguments\"));\n        }\n        // The alias has to be parsed here, to make sure options are respected.\n        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);\n        return subselects_1.subselects.is(next, alias, options, context, compileToken);\n    }\n    if (name in filters_1.filters) {\n        return filters_1.filters[name](next, data, options, context);\n    }\n    if (name in pseudos_1.pseudos) {\n        var pseudo_1 = pseudos_1.pseudos[name];\n        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);\n        return pseudo_1 === boolbase_1.falseFunc\n            ? boolbase_1.falseFunc\n            : next === boolbase_1.trueFunc\n                ? function (elem) { return pseudo_1(elem, options, data); }\n                : function (elem) { return pseudo_1(elem, options, data) && next(elem); };\n    }\n    throw new Error(\"unmatched pseudo-class :\".concat(name));\n}\nexports.compilePseudoSelector = compilePseudoSelector;\n"]},"metadata":{},"sourceType":"script"}