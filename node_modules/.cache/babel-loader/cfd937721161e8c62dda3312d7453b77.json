{"ast":null,"code":"import { extend, isArray, isMap, isIntegerKey, isSymbol, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n  console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nconst effectScopeStack = [];\n\nclass EffectScope {\n  constructor(detached = false) {\n    this.active = true;\n    this.effects = [];\n    this.cleanups = [];\n\n    if (!detached && activeEffectScope) {\n      this.parent = activeEffectScope;\n      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n    }\n  }\n\n  run(fn) {\n    if (this.active) {\n      try {\n        this.on();\n        return fn();\n      } finally {\n        this.off();\n      }\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`cannot run an inactive effect scope.`);\n    }\n  }\n\n  on() {\n    if (this.active) {\n      effectScopeStack.push(this);\n      activeEffectScope = this;\n    }\n  }\n\n  off() {\n    if (this.active) {\n      effectScopeStack.pop();\n      activeEffectScope = effectScopeStack[effectScopeStack.length - 1];\n    }\n  }\n\n  stop(fromParent) {\n    if (this.active) {\n      this.effects.forEach(e => e.stop());\n      this.cleanups.forEach(cleanup => cleanup());\n\n      if (this.scopes) {\n        this.scopes.forEach(e => e.stop(true));\n      } // nested scope, dereference from parent to avoid memory leaks\n\n\n      if (this.parent && !fromParent) {\n        // optimized O(1) removal\n        const last = this.parent.scopes.pop();\n\n        if (last && last !== this) {\n          this.parent.scopes[this.index] = last;\n          last.index = this.index;\n        }\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction effectScope(detached) {\n  return new EffectScope(detached);\n}\n\nfunction recordEffectScope(effect, scope) {\n  scope = scope || activeEffectScope;\n\n  if (scope && scope.active) {\n    scope.effects.push(effect);\n  }\n}\n\nfunction getCurrentScope() {\n  return activeEffectScope;\n}\n\nfunction onScopeDispose(fn) {\n  if (activeEffectScope) {\n    activeEffectScope.cleanups.push(fn);\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn(`onScopeDispose() is called when there is no active effect scope` + ` to be associated with.`);\n  }\n}\n\nconst createDep = effects => {\n  const dep = new Set(effects);\n  dep.w = 0;\n  dep.n = 0;\n  return dep;\n};\n\nconst wasTracked = dep => (dep.w & trackOpBit) > 0;\n\nconst newTracked = dep => (dep.n & trackOpBit) > 0;\n\nconst initDepMarkers = ({\n  deps\n}) => {\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].w |= trackOpBit; // set was tracked\n    }\n  }\n};\n\nconst finalizeDepMarkers = effect => {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    let ptr = 0;\n\n    for (let i = 0; i < deps.length; i++) {\n      const dep = deps[i];\n\n      if (wasTracked(dep) && !newTracked(dep)) {\n        dep.delete(effect);\n      } else {\n        deps[ptr++] = dep;\n      } // clear bits\n\n\n      dep.w &= ~trackOpBit;\n      dep.n &= ~trackOpBit;\n    }\n\n    deps.length = ptr;\n  }\n};\n\nconst targetMap = new WeakMap(); // The number of effects currently being tracked recursively.\n\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\n\nconst maxMarkerBits = 30;\nconst effectStack = [];\nlet activeEffect;\nconst ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol(process.env.NODE_ENV !== 'production' ? 'Map key iterate' : '');\n\nclass ReactiveEffect {\n  constructor(fn, scheduler = null, scope) {\n    this.fn = fn;\n    this.scheduler = scheduler;\n    this.active = true;\n    this.deps = [];\n    recordEffectScope(this, scope);\n  }\n\n  run() {\n    if (!this.active) {\n      return this.fn();\n    }\n\n    if (!effectStack.includes(this)) {\n      try {\n        effectStack.push(activeEffect = this);\n        enableTracking();\n        trackOpBit = 1 << ++effectTrackDepth;\n\n        if (effectTrackDepth <= maxMarkerBits) {\n          initDepMarkers(this);\n        } else {\n          cleanupEffect(this);\n        }\n\n        return this.fn();\n      } finally {\n        if (effectTrackDepth <= maxMarkerBits) {\n          finalizeDepMarkers(this);\n        }\n\n        trackOpBit = 1 << --effectTrackDepth;\n        resetTracking();\n        effectStack.pop();\n        const n = effectStack.length;\n        activeEffect = n > 0 ? effectStack[n - 1] : undefined;\n      }\n    }\n  }\n\n  stop() {\n    if (this.active) {\n      cleanupEffect(this);\n\n      if (this.onStop) {\n        this.onStop();\n      }\n\n      this.active = false;\n    }\n  }\n\n}\n\nfunction cleanupEffect(effect) {\n  const {\n    deps\n  } = effect;\n\n  if (deps.length) {\n    for (let i = 0; i < deps.length; i++) {\n      deps[i].delete(effect);\n    }\n\n    deps.length = 0;\n  }\n}\n\nfunction effect(fn, options) {\n  if (fn.effect) {\n    fn = fn.effect.fn;\n  }\n\n  const _effect = new ReactiveEffect(fn);\n\n  if (options) {\n    extend(_effect, options);\n    if (options.scope) recordEffectScope(_effect, options.scope);\n  }\n\n  if (!options || !options.lazy) {\n    _effect.run();\n  }\n\n  const runner = _effect.run.bind(_effect);\n\n  runner.effect = _effect;\n  return runner;\n}\n\nfunction stop(runner) {\n  runner.effect.stop();\n}\n\nlet shouldTrack = true;\nconst trackStack = [];\n\nfunction pauseTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = false;\n}\n\nfunction enableTracking() {\n  trackStack.push(shouldTrack);\n  shouldTrack = true;\n}\n\nfunction resetTracking() {\n  const last = trackStack.pop();\n  shouldTrack = last === undefined ? true : last;\n}\n\nfunction track(target, type, key) {\n  if (!isTracking()) {\n    return;\n  }\n\n  let depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    targetMap.set(target, depsMap = new Map());\n  }\n\n  let dep = depsMap.get(key);\n\n  if (!dep) {\n    depsMap.set(key, dep = createDep());\n  }\n\n  const eventInfo = process.env.NODE_ENV !== 'production' ? {\n    effect: activeEffect,\n    target,\n    type,\n    key\n  } : undefined;\n  trackEffects(dep, eventInfo);\n}\n\nfunction isTracking() {\n  return shouldTrack && activeEffect !== undefined;\n}\n\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n  let shouldTrack = false;\n\n  if (effectTrackDepth <= maxMarkerBits) {\n    if (!newTracked(dep)) {\n      dep.n |= trackOpBit; // set newly tracked\n\n      shouldTrack = !wasTracked(dep);\n    }\n  } else {\n    // Full cleanup mode.\n    shouldTrack = !dep.has(activeEffect);\n  }\n\n  if (shouldTrack) {\n    dep.add(activeEffect);\n    activeEffect.deps.push(dep);\n\n    if (process.env.NODE_ENV !== 'production' && activeEffect.onTrack) {\n      activeEffect.onTrack(Object.assign({\n        effect: activeEffect\n      }, debuggerEventExtraInfo));\n    }\n  }\n}\n\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n  const depsMap = targetMap.get(target);\n\n  if (!depsMap) {\n    // never been tracked\n    return;\n  }\n\n  let deps = [];\n\n  if (type === \"clear\"\n  /* CLEAR */\n  ) {\n    // collection being cleared\n    // trigger all effects for target\n    deps = [...depsMap.values()];\n  } else if (key === 'length' && isArray(target)) {\n    depsMap.forEach((dep, key) => {\n      if (key === 'length' || key >= newValue) {\n        deps.push(dep);\n      }\n    });\n  } else {\n    // schedule runs for SET | ADD | DELETE\n    if (key !== void 0) {\n      deps.push(depsMap.get(key));\n    } // also run for iteration key on ADD | DELETE | Map.SET\n\n\n    switch (type) {\n      case \"add\"\n      /* ADD */\n      :\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        } else if (isIntegerKey(key)) {\n          // new index added to array -> length changes\n          deps.push(depsMap.get('length'));\n        }\n\n        break;\n\n      case \"delete\"\n      /* DELETE */\n      :\n        if (!isArray(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n\n          if (isMap(target)) {\n            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n          }\n        }\n\n        break;\n\n      case \"set\"\n      /* SET */\n      :\n        if (isMap(target)) {\n          deps.push(depsMap.get(ITERATE_KEY));\n        }\n\n        break;\n    }\n  }\n\n  const eventInfo = process.env.NODE_ENV !== 'production' ? {\n    target,\n    type,\n    key,\n    newValue,\n    oldValue,\n    oldTarget\n  } : undefined;\n\n  if (deps.length === 1) {\n    if (deps[0]) {\n      if (process.env.NODE_ENV !== 'production') {\n        triggerEffects(deps[0], eventInfo);\n      } else {\n        triggerEffects(deps[0]);\n      }\n    }\n  } else {\n    const effects = [];\n\n    for (const dep of deps) {\n      if (dep) {\n        effects.push(...dep);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(createDep(effects), eventInfo);\n    } else {\n      triggerEffects(createDep(effects));\n    }\n  }\n}\n\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n  // spread into array for stabilization\n  for (const effect of isArray(dep) ? dep : [...dep]) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n      if (process.env.NODE_ENV !== 'production' && effect.onTrigger) {\n        effect.onTrigger(extend({\n          effect\n        }, debuggerEventExtraInfo));\n      }\n\n      if (effect.scheduler) {\n        effect.scheduler();\n      } else {\n        effect.run();\n      }\n    }\n  }\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map(key => Symbol[key]).filter(isSymbol));\nconst get = /*#__PURE__*/createGetter();\nconst shallowGet = /*#__PURE__*/createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/createArrayInstrumentations();\n\nfunction createArrayInstrumentations() {\n  const instrumentations = {};\n  ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      const arr = toRaw(this);\n\n      for (let i = 0, l = this.length; i < l; i++) {\n        track(arr, \"get\"\n        /* GET */\n        , i + '');\n      } // we run the method using the original args first (which may be reactive)\n\n\n      const res = arr[key](...args);\n\n      if (res === -1 || res === false) {\n        // if that didn't work, run it again using raw values.\n        return arr[key](...args.map(toRaw));\n      } else {\n        return res;\n      }\n    };\n  });\n  ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n    instrumentations[key] = function (...args) {\n      pauseTracking();\n      const res = toRaw(this)[key].apply(this, args);\n      resetTracking();\n      return res;\n    };\n  });\n  return instrumentations;\n}\n\nfunction createGetter(isReadonly = false, shallow = false) {\n  return function get(target, key, receiver) {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_raw\"\n    /* RAW */\n    && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {\n      return target;\n    }\n\n    const targetIsArray = isArray(target);\n\n    if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\n      return Reflect.get(arrayInstrumentations, key, receiver);\n    }\n\n    const res = Reflect.get(target, key, receiver);\n\n    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n      return res;\n    }\n\n    if (!isReadonly) {\n      track(target, \"get\"\n      /* GET */\n      , key);\n    }\n\n    if (shallow) {\n      return res;\n    }\n\n    if (isRef(res)) {\n      // ref unwrapping - does not apply for Array + integer key.\n      const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n      return shouldUnwrap ? res.value : res;\n    }\n\n    if (isObject(res)) {\n      // Convert returned value into a proxy as well. we do the isObject check\n      // here to avoid invalid value warning. Also need to lazy access readonly\n      // and reactive here to avoid circular dependency.\n      return isReadonly ? readonly(res) : reactive(res);\n    }\n\n    return res;\n  };\n}\n\nconst set = /*#__PURE__*/createSetter();\nconst shallowSet = /*#__PURE__*/createSetter(true);\n\nfunction createSetter(shallow = false) {\n  return function set(target, key, value, receiver) {\n    let oldValue = target[key];\n\n    if (!shallow && !isReadonly(value)) {\n      value = toRaw(value);\n      oldValue = toRaw(oldValue);\n\n      if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n        oldValue.value = value;\n        return true;\n      }\n    }\n\n    const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);\n    const result = Reflect.set(target, key, value, receiver); // don't trigger if target is something up in the prototype chain of original\n\n    if (target === toRaw(receiver)) {\n      if (!hadKey) {\n        trigger(target, \"add\"\n        /* ADD */\n        , key, value);\n      } else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\"\n        /* SET */\n        , key, value, oldValue);\n      }\n    }\n\n    return result;\n  };\n}\n\nfunction deleteProperty(target, key) {\n  const hadKey = hasOwn(target, key);\n  const oldValue = target[key];\n  const result = Reflect.deleteProperty(target, key);\n\n  if (result && hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction has(target, key) {\n  const result = Reflect.has(target, key);\n\n  if (!isSymbol(key) || !builtInSymbols.has(key)) {\n    track(target, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  return result;\n}\n\nfunction ownKeys(target) {\n  track(target, \"iterate\"\n  /* ITERATE */\n  , isArray(target) ? 'length' : ITERATE_KEY);\n  return Reflect.ownKeys(target);\n}\n\nconst mutableHandlers = {\n  get,\n  set,\n  deleteProperty,\n  has,\n  ownKeys\n};\nconst readonlyHandlers = {\n  get: readonlyGet,\n\n  set(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  },\n\n  deleteProperty(target, key) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n    }\n\n    return true;\n  }\n\n};\nconst shallowReactiveHandlers = /*#__PURE__*/extend({}, mutableHandlers, {\n  get: shallowGet,\n  set: shallowSet\n}); // Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\n\nconst shallowReadonlyHandlers = /*#__PURE__*/extend({}, readonlyHandlers, {\n  get: shallowReadonlyGet\n});\n\nconst toShallow = value => value;\n\nconst getProto = v => Reflect.getPrototypeOf(v);\n\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\n  // #1772: readonly(reactive(Map)) should return readonly + reactive version\n  // of the value\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"get\"\n    /* GET */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"get\"\n  /* GET */\n  , rawKey);\n  const {\n    has\n  } = getProto(rawTarget);\n  const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n\n  if (has.call(rawTarget, key)) {\n    return wrap(target.get(key));\n  } else if (has.call(rawTarget, rawKey)) {\n    return wrap(target.get(rawKey));\n  } else if (target !== rawTarget) {\n    // #3602 readonly(reactive(Map))\n    // ensure that the nested reactive `Map` can do tracking for itself\n    target.get(key);\n  }\n}\n\nfunction has$1(key, isReadonly = false) {\n  const target = this[\"__v_raw\"\n  /* RAW */\n  ];\n  const rawTarget = toRaw(target);\n  const rawKey = toRaw(key);\n\n  if (key !== rawKey) {\n    !isReadonly && track(rawTarget, \"has\"\n    /* HAS */\n    , key);\n  }\n\n  !isReadonly && track(rawTarget, \"has\"\n  /* HAS */\n  , rawKey);\n  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);\n}\n\nfunction size(target, isReadonly = false) {\n  target = target[\"__v_raw\"\n  /* RAW */\n  ];\n  !isReadonly && track(toRaw(target), \"iterate\"\n  /* ITERATE */\n  , ITERATE_KEY);\n  return Reflect.get(target, 'size', target);\n}\n\nfunction add(value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const proto = getProto(target);\n  const hadKey = proto.has.call(target, value);\n\n  if (!hadKey) {\n    target.add(value);\n    trigger(target, \"add\"\n    /* ADD */\n    , value, value);\n  }\n\n  return this;\n}\n\nfunction set$1(key, value) {\n  value = toRaw(value);\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get.call(target, key);\n  target.set(key, value);\n\n  if (!hadKey) {\n    trigger(target, \"add\"\n    /* ADD */\n    , key, value);\n  } else if (hasChanged(value, oldValue)) {\n    trigger(target, \"set\"\n    /* SET */\n    , key, value, oldValue);\n  }\n\n  return this;\n}\n\nfunction deleteEntry(key) {\n  const target = toRaw(this);\n  const {\n    has,\n    get\n  } = getProto(target);\n  let hadKey = has.call(target, key);\n\n  if (!hadKey) {\n    key = toRaw(key);\n    hadKey = has.call(target, key);\n  } else if (process.env.NODE_ENV !== 'production') {\n    checkIdentityKeys(target, has, key);\n  }\n\n  const oldValue = get ? get.call(target, key) : undefined; // forward the operation before queueing reactions\n\n  const result = target.delete(key);\n\n  if (hadKey) {\n    trigger(target, \"delete\"\n    /* DELETE */\n    , key, undefined, oldValue);\n  }\n\n  return result;\n}\n\nfunction clear() {\n  const target = toRaw(this);\n  const hadItems = target.size !== 0;\n  const oldTarget = process.env.NODE_ENV !== 'production' ? isMap(target) ? new Map(target) : new Set(target) : undefined; // forward the operation before queueing reactions\n\n  const result = target.clear();\n\n  if (hadItems) {\n    trigger(target, \"clear\"\n    /* CLEAR */\n    , undefined, undefined, oldTarget);\n  }\n\n  return result;\n}\n\nfunction createForEach(isReadonly, isShallow) {\n  return function forEach(callback, thisArg) {\n    const observed = this;\n    const target = observed[\"__v_raw\"\n    /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , ITERATE_KEY);\n    return target.forEach((value, key) => {\n      // important: make sure the callback is\n      // 1. invoked with the reactive map as `this` and 3rd arg\n      // 2. the value received should be a corresponding reactive/readonly.\n      return callback.call(thisArg, wrap(value), wrap(key), observed);\n    });\n  };\n}\n\nfunction createIterableMethod(method, isReadonly, isShallow) {\n  return function (...args) {\n    const target = this[\"__v_raw\"\n    /* RAW */\n    ];\n    const rawTarget = toRaw(target);\n    const targetIsMap = isMap(rawTarget);\n    const isPair = method === 'entries' || method === Symbol.iterator && targetIsMap;\n    const isKeyOnly = method === 'keys' && targetIsMap;\n    const innerIterator = target[method](...args);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    !isReadonly && track(rawTarget, \"iterate\"\n    /* ITERATE */\n    , isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY); // return a wrapped iterator which returns observed versions of the\n    // values emitted from the real iterator\n\n    return {\n      // iterator protocol\n      next() {\n        const {\n          value,\n          done\n        } = innerIterator.next();\n        return done ? {\n          value,\n          done\n        } : {\n          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n          done\n        };\n      },\n\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n\n    };\n  };\n}\n\nfunction createReadonlyMethod(type) {\n  return function (...args) {\n    if (process.env.NODE_ENV !== 'production') {\n      const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n      console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n    }\n\n    return type === \"delete\"\n    /* DELETE */\n    ? false : this;\n  };\n}\n\nfunction createInstrumentations() {\n  const mutableInstrumentations = {\n    get(key) {\n      return get$1(this, key);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, false)\n  };\n  const shallowInstrumentations = {\n    get(key) {\n      return get$1(this, key, false, true);\n    },\n\n    get size() {\n      return size(this);\n    },\n\n    has: has$1,\n    add,\n    set: set$1,\n    delete: deleteEntry,\n    clear,\n    forEach: createForEach(false, true)\n  };\n  const readonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"\n    /* ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* CLEAR */\n    ),\n    forEach: createForEach(true, false)\n  };\n  const shallowReadonlyInstrumentations = {\n    get(key) {\n      return get$1(this, key, true, true);\n    },\n\n    get size() {\n      return size(this, true);\n    },\n\n    has(key) {\n      return has$1.call(this, key, true);\n    },\n\n    add: createReadonlyMethod(\"add\"\n    /* ADD */\n    ),\n    set: createReadonlyMethod(\"set\"\n    /* SET */\n    ),\n    delete: createReadonlyMethod(\"delete\"\n    /* DELETE */\n    ),\n    clear: createReadonlyMethod(\"clear\"\n    /* CLEAR */\n    ),\n    forEach: createForEach(true, true)\n  };\n  const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n  iteratorMethods.forEach(method => {\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\n    shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n  });\n  return [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations];\n}\n\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/createInstrumentations();\n\nfunction createInstrumentationGetter(isReadonly, shallow) {\n  const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;\n  return (target, key, receiver) => {\n    if (key === \"__v_isReactive\"\n    /* IS_REACTIVE */\n    ) {\n      return !isReadonly;\n    } else if (key === \"__v_isReadonly\"\n    /* IS_READONLY */\n    ) {\n      return isReadonly;\n    } else if (key === \"__v_raw\"\n    /* RAW */\n    ) {\n      return target;\n    }\n\n    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);\n  };\n}\n\nconst mutableCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n  get: /*#__PURE__*/createInstrumentationGetter(true, true)\n};\n\nfunction checkIdentityKeys(target, has, key) {\n  const rawKey = toRaw(key);\n\n  if (rawKey !== key && has.call(target, rawKey)) {\n    const type = toRawType(target);\n    console.warn(`Reactive ${type} contains both the raw and reactive ` + `versions of the same object${type === `Map` ? ` as keys` : ``}, ` + `which can lead to inconsistencies. ` + `Avoid differentiating between the raw and reactive versions ` + `of an object and only use the reactive version if possible.`);\n  }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\n\nfunction targetTypeMap(rawType) {\n  switch (rawType) {\n    case 'Object':\n    case 'Array':\n      return 1\n      /* COMMON */\n      ;\n\n    case 'Map':\n    case 'Set':\n    case 'WeakMap':\n    case 'WeakSet':\n      return 2\n      /* COLLECTION */\n      ;\n\n    default:\n      return 0\n      /* INVALID */\n      ;\n  }\n}\n\nfunction getTargetType(value) {\n  return value[\"__v_skip\"\n  /* SKIP */\n  ] || !Object.isExtensible(value) ? 0\n  /* INVALID */\n  : targetTypeMap(toRawType(value));\n}\n\nfunction reactive(target) {\n  // if trying to observe a readonly proxy, return the readonly version.\n  if (target && target[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]) {\n    return target;\n  }\n\n  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\n\n\nfunction shallowReactive(target) {\n  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\n\n\nfunction readonly(target) {\n  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\n\n\nfunction shallowReadonly(target) {\n  return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\n\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n  if (!isObject(target)) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(`value cannot be made reactive: ${String(target)}`);\n    }\n\n    return target;\n  } // target is already a Proxy, return it.\n  // exception: calling readonly() on a reactive object\n\n\n  if (target[\"__v_raw\"\n  /* RAW */\n  ] && !(isReadonly && target[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ])) {\n    return target;\n  } // target already has corresponding Proxy\n\n\n  const existingProxy = proxyMap.get(target);\n\n  if (existingProxy) {\n    return existingProxy;\n  } // only a whitelist of value types can be observed.\n\n\n  const targetType = getTargetType(target);\n\n  if (targetType === 0\n  /* INVALID */\n  ) {\n    return target;\n  }\n\n  const proxy = new Proxy(target, targetType === 2\n  /* COLLECTION */\n  ? collectionHandlers : baseHandlers);\n  proxyMap.set(target, proxy);\n  return proxy;\n}\n\nfunction isReactive(value) {\n  if (isReadonly(value)) {\n    return isReactive(value[\"__v_raw\"\n    /* RAW */\n    ]);\n  }\n\n  return !!(value && value[\"__v_isReactive\"\n  /* IS_REACTIVE */\n  ]);\n}\n\nfunction isReadonly(value) {\n  return !!(value && value[\"__v_isReadonly\"\n  /* IS_READONLY */\n  ]);\n}\n\nfunction isProxy(value) {\n  return isReactive(value) || isReadonly(value);\n}\n\nfunction toRaw(observed) {\n  const raw = observed && observed[\"__v_raw\"\n  /* RAW */\n  ];\n  return raw ? toRaw(raw) : observed;\n}\n\nfunction markRaw(value) {\n  def(value, \"__v_skip\"\n  /* SKIP */\n  , true);\n  return value;\n}\n\nconst toReactive = value => isObject(value) ? reactive(value) : value;\n\nconst toReadonly = value => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n  if (isTracking()) {\n    ref = toRaw(ref);\n\n    if (!ref.dep) {\n      ref.dep = createDep();\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      trackEffects(ref.dep, {\n        target: ref,\n        type: \"get\"\n        /* GET */\n        ,\n        key: 'value'\n      });\n    } else {\n      trackEffects(ref.dep);\n    }\n  }\n}\n\nfunction triggerRefValue(ref, newVal) {\n  ref = toRaw(ref);\n\n  if (ref.dep) {\n    if (process.env.NODE_ENV !== 'production') {\n      triggerEffects(ref.dep, {\n        target: ref,\n        type: \"set\"\n        /* SET */\n        ,\n        key: 'value',\n        newValue: newVal\n      });\n    } else {\n      triggerEffects(ref.dep);\n    }\n  }\n}\n\nfunction isRef(r) {\n  return Boolean(r && r.__v_isRef === true);\n}\n\nfunction ref(value) {\n  return createRef(value, false);\n}\n\nfunction shallowRef(value) {\n  return createRef(value, true);\n}\n\nfunction createRef(rawValue, shallow) {\n  if (isRef(rawValue)) {\n    return rawValue;\n  }\n\n  return new RefImpl(rawValue, shallow);\n}\n\nclass RefImpl {\n  constructor(value, _shallow) {\n    this._shallow = _shallow;\n    this.dep = undefined;\n    this.__v_isRef = true;\n    this._rawValue = _shallow ? value : toRaw(value);\n    this._value = _shallow ? value : toReactive(value);\n  }\n\n  get value() {\n    trackRefValue(this);\n    return this._value;\n  }\n\n  set value(newVal) {\n    newVal = this._shallow ? newVal : toRaw(newVal);\n\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal;\n      this._value = this._shallow ? newVal : toReactive(newVal);\n      triggerRefValue(this, newVal);\n    }\n  }\n\n}\n\nfunction triggerRef(ref) {\n  triggerRefValue(ref, process.env.NODE_ENV !== 'production' ? ref.value : void 0);\n}\n\nfunction unref(ref) {\n  return isRef(ref) ? ref.value : ref;\n}\n\nconst shallowUnwrapHandlers = {\n  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n  set: (target, key, value, receiver) => {\n    const oldValue = target[key];\n\n    if (isRef(oldValue) && !isRef(value)) {\n      oldValue.value = value;\n      return true;\n    } else {\n      return Reflect.set(target, key, value, receiver);\n    }\n  }\n};\n\nfunction proxyRefs(objectWithRefs) {\n  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\n\nclass CustomRefImpl {\n  constructor(factory) {\n    this.dep = undefined;\n    this.__v_isRef = true;\n    const {\n      get,\n      set\n    } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n    this._get = get;\n    this._set = set;\n  }\n\n  get value() {\n    return this._get();\n  }\n\n  set value(newVal) {\n    this._set(newVal);\n  }\n\n}\n\nfunction customRef(factory) {\n  return new CustomRefImpl(factory);\n}\n\nfunction toRefs(object) {\n  if (process.env.NODE_ENV !== 'production' && !isProxy(object)) {\n    console.warn(`toRefs() expects a reactive object but received a plain one.`);\n  }\n\n  const ret = isArray(object) ? new Array(object.length) : {};\n\n  for (const key in object) {\n    ret[key] = toRef(object, key);\n  }\n\n  return ret;\n}\n\nclass ObjectRefImpl {\n  constructor(_object, _key, _defaultValue) {\n    this._object = _object;\n    this._key = _key;\n    this._defaultValue = _defaultValue;\n    this.__v_isRef = true;\n  }\n\n  get value() {\n    const val = this._object[this._key];\n    return val === undefined ? this._defaultValue : val;\n  }\n\n  set value(newVal) {\n    this._object[this._key] = newVal;\n  }\n\n}\n\nfunction toRef(object, key, defaultValue) {\n  const val = object[key];\n  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);\n}\n\nclass ComputedRefImpl {\n  constructor(getter, _setter, isReadonly) {\n    this._setter = _setter;\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this.effect = new ReactiveEffect(getter, () => {\n      if (!this._dirty) {\n        this._dirty = true;\n        triggerRefValue(this);\n      }\n    });\n    this[\"__v_isReadonly\"\n    /* IS_READONLY */\n    ] = isReadonly;\n  }\n\n  get value() {\n    // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n    const self = toRaw(this);\n    trackRefValue(self);\n\n    if (self._dirty) {\n      self._dirty = false;\n      self._value = self.effect.run();\n    }\n\n    return self._value;\n  }\n\n  set value(newValue) {\n    this._setter(newValue);\n  }\n\n}\n\nfunction computed(getterOrOptions, debugOptions) {\n  let getter;\n  let setter;\n  const onlyGetter = isFunction(getterOrOptions);\n\n  if (onlyGetter) {\n    getter = getterOrOptions;\n    setter = process.env.NODE_ENV !== 'production' ? () => {\n      console.warn('Write operation failed: computed value is readonly');\n    } : NOOP;\n  } else {\n    getter = getterOrOptions.get;\n    setter = getterOrOptions.set;\n  }\n\n  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);\n\n  if (process.env.NODE_ENV !== 'production' && debugOptions) {\n    cRef.effect.onTrack = debugOptions.onTrack;\n    cRef.effect.onTrigger = debugOptions.onTrigger;\n  }\n\n  return cRef;\n}\n\nvar _a;\n\nconst tick = Promise.resolve();\nconst queue = [];\nlet queued = false;\n\nconst scheduler = fn => {\n  queue.push(fn);\n\n  if (!queued) {\n    queued = true;\n    tick.then(flush);\n  }\n};\n\nconst flush = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]();\n  }\n\n  queue.length = 0;\n  queued = false;\n};\n\nclass DeferredComputedRefImpl {\n  constructor(getter) {\n    this.dep = undefined;\n    this._dirty = true;\n    this.__v_isRef = true;\n    this[_a] = true;\n    let compareTarget;\n    let hasCompareTarget = false;\n    let scheduled = false;\n    this.effect = new ReactiveEffect(getter, computedTrigger => {\n      if (this.dep) {\n        if (computedTrigger) {\n          compareTarget = this._value;\n          hasCompareTarget = true;\n        } else if (!scheduled) {\n          const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n          scheduled = true;\n          hasCompareTarget = false;\n          scheduler(() => {\n            if (this.effect.active && this._get() !== valueToCompare) {\n              triggerRefValue(this);\n            }\n\n            scheduled = false;\n          });\n        } // chained upstream computeds are notified synchronously to ensure\n        // value invalidation in case of sync access; normal effects are\n        // deferred to be triggered in scheduler.\n\n\n        for (const e of this.dep) {\n          if (e.computed) {\n            e.scheduler(true\n            /* computedTrigger */\n            );\n          }\n        }\n      }\n\n      this._dirty = true;\n    });\n    this.effect.computed = true;\n  }\n\n  _get() {\n    if (this._dirty) {\n      this._dirty = false;\n      return this._value = this.effect.run();\n    }\n\n    return this._value;\n  }\n\n  get value() {\n    trackRefValue(this); // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n\n    return toRaw(this)._get();\n  }\n\n}\n\n_a = \"__v_isReadonly\"\n/* IS_READONLY */\n;\n\nfunction deferredComputed(getter) {\n  return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };","map":{"version":3,"sources":["/home/thomas/Code/FF/lingobingo/node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js"],"names":["extend","isArray","isMap","isIntegerKey","isSymbol","hasOwn","isObject","hasChanged","makeMap","capitalize","toRawType","def","isFunction","NOOP","warn","msg","args","console","activeEffectScope","effectScopeStack","EffectScope","constructor","detached","active","effects","cleanups","parent","index","scopes","push","run","fn","on","off","process","env","NODE_ENV","pop","length","stop","fromParent","forEach","e","cleanup","last","effectScope","recordEffectScope","effect","scope","getCurrentScope","onScopeDispose","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","i","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","effectStack","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","includes","enableTracking","cleanupEffect","resetTracking","undefined","onStop","options","_effect","lazy","runner","bind","shouldTrack","trackStack","pauseTracking","track","target","type","key","isTracking","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","onTrack","Object","assign","trigger","newValue","oldValue","oldTarget","values","triggerEffects","allowRecurse","onTrigger","isNonTrackableKeys","builtInSymbols","getOwnPropertyNames","map","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","arr","toRaw","l","res","apply","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","Reflect","isRef","shouldUnwrap","value","readonly","reactive","createSetter","shallowSet","hadKey","Number","result","deleteProperty","ownKeys","mutableHandlers","readonlyHandlers","String","shallowReactiveHandlers","shallowReadonlyHandlers","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","toReadonly","toReactive","call","has$1","size","proto","set$1","checkIdentityKeys","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","shallowReadonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","createReactiveObject","shallowReactive","shallowReadonly","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","trackRefValue","ref","triggerRefValue","newVal","r","Boolean","__v_isRef","createRef","shallowRef","rawValue","RefImpl","_shallow","_rawValue","_value","triggerRef","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","CustomRefImpl","factory","_get","_set","customRef","toRefs","object","ret","Array","toRef","ObjectRefImpl","_object","_key","_defaultValue","val","defaultValue","ComputedRefImpl","getter","_setter","_dirty","self","computed","getterOrOptions","debugOptions","setter","onlyGetter","cRef","_a","tick","Promise","resolve","queue","queued","then","flush","DeferredComputedRefImpl","compareTarget","hasCompareTarget","scheduled","computedTrigger","valueToCompare","deferredComputed"],"mappings":"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","sourcesContent":["import { extend, isArray, isMap, isIntegerKey, isSymbol, hasOwn, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\r\n    console.warn(`[Vue warn] ${msg}`, ...args);\r\n}\n\nlet activeEffectScope;\r\nconst effectScopeStack = [];\r\nclass EffectScope {\r\n    constructor(detached = false) {\r\n        this.active = true;\r\n        this.effects = [];\r\n        this.cleanups = [];\r\n        if (!detached && activeEffectScope) {\r\n            this.parent = activeEffectScope;\r\n            this.index =\r\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\r\n        }\r\n    }\r\n    run(fn) {\r\n        if (this.active) {\r\n            try {\r\n                this.on();\r\n                return fn();\r\n            }\r\n            finally {\r\n                this.off();\r\n            }\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`cannot run an inactive effect scope.`);\r\n        }\r\n    }\r\n    on() {\r\n        if (this.active) {\r\n            effectScopeStack.push(this);\r\n            activeEffectScope = this;\r\n        }\r\n    }\r\n    off() {\r\n        if (this.active) {\r\n            effectScopeStack.pop();\r\n            activeEffectScope = effectScopeStack[effectScopeStack.length - 1];\r\n        }\r\n    }\r\n    stop(fromParent) {\r\n        if (this.active) {\r\n            this.effects.forEach(e => e.stop());\r\n            this.cleanups.forEach(cleanup => cleanup());\r\n            if (this.scopes) {\r\n                this.scopes.forEach(e => e.stop(true));\r\n            }\r\n            // nested scope, dereference from parent to avoid memory leaks\r\n            if (this.parent && !fromParent) {\r\n                // optimized O(1) removal\r\n                const last = this.parent.scopes.pop();\r\n                if (last && last !== this) {\r\n                    this.parent.scopes[this.index] = last;\r\n                    last.index = this.index;\r\n                }\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction effectScope(detached) {\r\n    return new EffectScope(detached);\r\n}\r\nfunction recordEffectScope(effect, scope) {\r\n    scope = scope || activeEffectScope;\r\n    if (scope && scope.active) {\r\n        scope.effects.push(effect);\r\n    }\r\n}\r\nfunction getCurrentScope() {\r\n    return activeEffectScope;\r\n}\r\nfunction onScopeDispose(fn) {\r\n    if (activeEffectScope) {\r\n        activeEffectScope.cleanups.push(fn);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        warn(`onScopeDispose() is called when there is no active effect scope` +\r\n            ` to be associated with.`);\r\n    }\r\n}\n\nconst createDep = (effects) => {\r\n    const dep = new Set(effects);\r\n    dep.w = 0;\r\n    dep.n = 0;\r\n    return dep;\r\n};\r\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\r\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\r\nconst initDepMarkers = ({ deps }) => {\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].w |= trackOpBit; // set was tracked\r\n        }\r\n    }\r\n};\r\nconst finalizeDepMarkers = (effect) => {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        let ptr = 0;\r\n        for (let i = 0; i < deps.length; i++) {\r\n            const dep = deps[i];\r\n            if (wasTracked(dep) && !newTracked(dep)) {\r\n                dep.delete(effect);\r\n            }\r\n            else {\r\n                deps[ptr++] = dep;\r\n            }\r\n            // clear bits\r\n            dep.w &= ~trackOpBit;\r\n            dep.n &= ~trackOpBit;\r\n        }\r\n        deps.length = ptr;\r\n    }\r\n};\n\nconst targetMap = new WeakMap();\r\n// The number of effects currently being tracked recursively.\r\nlet effectTrackDepth = 0;\r\nlet trackOpBit = 1;\r\n/**\r\n * The bitwise track markers support at most 30 levels of recursion.\r\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\r\n * When recursion depth is greater, fall back to using a full cleanup.\r\n */\r\nconst maxMarkerBits = 30;\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nclass ReactiveEffect {\r\n    constructor(fn, scheduler = null, scope) {\r\n        this.fn = fn;\r\n        this.scheduler = scheduler;\r\n        this.active = true;\r\n        this.deps = [];\r\n        recordEffectScope(this, scope);\r\n    }\r\n    run() {\r\n        if (!this.active) {\r\n            return this.fn();\r\n        }\r\n        if (!effectStack.includes(this)) {\r\n            try {\r\n                effectStack.push((activeEffect = this));\r\n                enableTracking();\r\n                trackOpBit = 1 << ++effectTrackDepth;\r\n                if (effectTrackDepth <= maxMarkerBits) {\r\n                    initDepMarkers(this);\r\n                }\r\n                else {\r\n                    cleanupEffect(this);\r\n                }\r\n                return this.fn();\r\n            }\r\n            finally {\r\n                if (effectTrackDepth <= maxMarkerBits) {\r\n                    finalizeDepMarkers(this);\r\n                }\r\n                trackOpBit = 1 << --effectTrackDepth;\r\n                resetTracking();\r\n                effectStack.pop();\r\n                const n = effectStack.length;\r\n                activeEffect = n > 0 ? effectStack[n - 1] : undefined;\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        if (this.active) {\r\n            cleanupEffect(this);\r\n            if (this.onStop) {\r\n                this.onStop();\r\n            }\r\n            this.active = false;\r\n        }\r\n    }\r\n}\r\nfunction cleanupEffect(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nfunction effect(fn, options) {\r\n    if (fn.effect) {\r\n        fn = fn.effect.fn;\r\n    }\r\n    const _effect = new ReactiveEffect(fn);\r\n    if (options) {\r\n        extend(_effect, options);\r\n        if (options.scope)\r\n            recordEffectScope(_effect, options.scope);\r\n    }\r\n    if (!options || !options.lazy) {\r\n        _effect.run();\r\n    }\r\n    const runner = _effect.run.bind(_effect);\r\n    runner.effect = _effect;\r\n    return runner;\r\n}\r\nfunction stop(runner) {\r\n    runner.effect.stop();\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!isTracking()) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = createDep()));\r\n    }\r\n    const eventInfo = (process.env.NODE_ENV !== 'production')\r\n        ? { effect: activeEffect, target, type, key }\r\n        : undefined;\r\n    trackEffects(dep, eventInfo);\r\n}\r\nfunction isTracking() {\r\n    return shouldTrack && activeEffect !== undefined;\r\n}\r\nfunction trackEffects(dep, debuggerEventExtraInfo) {\r\n    let shouldTrack = false;\r\n    if (effectTrackDepth <= maxMarkerBits) {\r\n        if (!newTracked(dep)) {\r\n            dep.n |= trackOpBit; // set newly tracked\r\n            shouldTrack = !wasTracked(dep);\r\n        }\r\n    }\r\n    else {\r\n        // Full cleanup mode.\r\n        shouldTrack = !dep.has(activeEffect);\r\n    }\r\n    if (shouldTrack) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\r\n            activeEffect.onTrack(Object.assign({\r\n                effect: activeEffect\r\n            }, debuggerEventExtraInfo));\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    let deps = [];\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        deps = [...depsMap.values()];\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                deps.push(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            deps.push(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    deps.push(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    deps.push(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const eventInfo = (process.env.NODE_ENV !== 'production')\r\n        ? { target, type, key, newValue, oldValue, oldTarget }\r\n        : undefined;\r\n    if (deps.length === 1) {\r\n        if (deps[0]) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                triggerEffects(deps[0], eventInfo);\r\n            }\r\n            else {\r\n                triggerEffects(deps[0]);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        const effects = [];\r\n        for (const dep of deps) {\r\n            if (dep) {\r\n                effects.push(...dep);\r\n            }\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            triggerEffects(createDep(effects), eventInfo);\r\n        }\r\n        else {\r\n            triggerEffects(createDep(effects));\r\n        }\r\n    }\r\n}\r\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\r\n    // spread into array for stabilization\r\n    for (const effect of isArray(dep) ? dep : [...dep]) {\r\n        if (effect !== activeEffect || effect.allowRecurse) {\r\n            if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\r\n                effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\r\n            }\r\n            if (effect.scheduler) {\r\n                effect.scheduler();\r\n            }\r\n            else {\r\n                effect.run();\r\n            }\r\n        }\r\n    }\r\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\r\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\r\nfunction createArrayInstrumentations() {\r\n    const instrumentations = {};\r\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            const arr = toRaw(this);\r\n            for (let i = 0, l = this.length; i < l; i++) {\r\n                track(arr, \"get\" /* GET */, i + '');\r\n            }\r\n            // we run the method using the original args first (which may be reactive)\r\n            const res = arr[key](...args);\r\n            if (res === -1 || res === false) {\r\n                // if that didn't work, run it again using raw values.\r\n                return arr[key](...args.map(toRaw));\r\n            }\r\n            else {\r\n                return res;\r\n            }\r\n        };\r\n    });\r\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n        instrumentations[key] = function (...args) {\r\n            pauseTracking();\r\n            const res = toRaw(this)[key].apply(this, args);\r\n            resetTracking();\r\n            return res;\r\n        };\r\n    });\r\n    return instrumentations;\r\n}\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver ===\r\n                (isReadonly\r\n                    ? shallow\r\n                        ? shallowReadonlyMap\r\n                        : readonlyMap\r\n                    : shallow\r\n                        ? shallowReactiveMap\r\n                        : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        let oldValue = target[key];\r\n        if (!shallow && !isReadonly(value)) {\r\n            value = toRaw(value);\r\n            oldValue = toRaw(oldValue);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n    else if (target !== rawTarget) {\r\n        // #3602 readonly(reactive(Map))\r\n        // ensure that the nested reactive `Map` can do tracking for itself\r\n        target.get(key);\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    if (!hadKey) {\r\n        target.add(value);\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nfunction createInstrumentations() {\r\n    const mutableInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, false)\r\n    };\r\n    const shallowInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, false, true);\r\n        },\r\n        get size() {\r\n            return size(this);\r\n        },\r\n        has: has$1,\r\n        add,\r\n        set: set$1,\r\n        delete: deleteEntry,\r\n        clear,\r\n        forEach: createForEach(false, true)\r\n    };\r\n    const readonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, false)\r\n    };\r\n    const shallowReadonlyInstrumentations = {\r\n        get(key) {\r\n            return get$1(this, key, true, true);\r\n        },\r\n        get size() {\r\n            return size(this, true);\r\n        },\r\n        has(key) {\r\n            return has$1.call(this, key, true);\r\n        },\r\n        add: createReadonlyMethod(\"add\" /* ADD */),\r\n        set: createReadonlyMethod(\"set\" /* SET */),\r\n        delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n        clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n        forEach: createForEach(true, true)\r\n    };\r\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\n    iteratorMethods.forEach(method => {\r\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\r\n    });\r\n    return [\r\n        mutableInstrumentations,\r\n        readonlyInstrumentations,\r\n        shallowInstrumentations,\r\n        shallowReadonlyInstrumentations\r\n    ];\r\n}\r\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? isReadonly\r\n            ? shallowReadonlyInstrumentations\r\n            : shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\r\n};\r\nconst shallowReadonlyCollectionHandlers = {\r\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst shallowReactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nconst shallowReadonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\r\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\r\n    if (isTracking()) {\r\n        ref = toRaw(ref);\r\n        if (!ref.dep) {\r\n            ref.dep = createDep();\r\n        }\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            trackEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"get\" /* GET */,\r\n                key: 'value'\r\n            });\r\n        }\r\n        else {\r\n            trackEffects(ref.dep);\r\n        }\r\n    }\r\n}\r\nfunction triggerRefValue(ref, newVal) {\r\n    ref = toRaw(ref);\r\n    if (ref.dep) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            triggerEffects(ref.dep, {\r\n                target: ref,\r\n                type: \"set\" /* SET */,\r\n                key: 'value',\r\n                newValue: newVal\r\n            });\r\n        }\r\n        else {\r\n            triggerEffects(ref.dep);\r\n        }\r\n    }\r\n}\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value, false);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nfunction createRef(rawValue, shallow) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nclass RefImpl {\r\n    constructor(value, _shallow) {\r\n        this._shallow = _shallow;\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        this._rawValue = _shallow ? value : toRaw(value);\r\n        this._value = _shallow ? value : toReactive(value);\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        newVal = this._shallow ? newVal : toRaw(newVal);\r\n        if (hasChanged(newVal, this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : toReactive(newVal);\r\n            triggerRefValue(this, newVal);\r\n        }\r\n    }\r\n}\r\nfunction triggerRef(ref) {\r\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.dep = undefined;\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key, _defaultValue) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this._defaultValue = _defaultValue;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        const val = this._object[this._key];\r\n        return val === undefined ? this._defaultValue : val;\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key, defaultValue) {\r\n    const val = object[key];\r\n    return isRef(val)\r\n        ? val\r\n        : new ObjectRefImpl(object, key, defaultValue);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = new ReactiveEffect(getter, () => {\r\n            if (!this._dirty) {\r\n                this._dirty = true;\r\n                triggerRefValue(this);\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        const self = toRaw(this);\r\n        trackRefValue(self);\r\n        if (self._dirty) {\r\n            self._dirty = false;\r\n            self._value = self.effect.run();\r\n        }\r\n        return self._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions, debugOptions) {\r\n    let getter;\r\n    let setter;\r\n    const onlyGetter = isFunction(getterOrOptions);\r\n    if (onlyGetter) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter);\r\n    if ((process.env.NODE_ENV !== 'production') && debugOptions) {\r\n        cRef.effect.onTrack = debugOptions.onTrack;\r\n        cRef.effect.onTrigger = debugOptions.onTrigger;\r\n    }\r\n    return cRef;\r\n}\n\nvar _a;\r\nconst tick = Promise.resolve();\r\nconst queue = [];\r\nlet queued = false;\r\nconst scheduler = (fn) => {\r\n    queue.push(fn);\r\n    if (!queued) {\r\n        queued = true;\r\n        tick.then(flush);\r\n    }\r\n};\r\nconst flush = () => {\r\n    for (let i = 0; i < queue.length; i++) {\r\n        queue[i]();\r\n    }\r\n    queue.length = 0;\r\n    queued = false;\r\n};\r\nclass DeferredComputedRefImpl {\r\n    constructor(getter) {\r\n        this.dep = undefined;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this[_a] = true;\r\n        let compareTarget;\r\n        let hasCompareTarget = false;\r\n        let scheduled = false;\r\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\r\n            if (this.dep) {\r\n                if (computedTrigger) {\r\n                    compareTarget = this._value;\r\n                    hasCompareTarget = true;\r\n                }\r\n                else if (!scheduled) {\r\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\r\n                    scheduled = true;\r\n                    hasCompareTarget = false;\r\n                    scheduler(() => {\r\n                        if (this.effect.active && this._get() !== valueToCompare) {\r\n                            triggerRefValue(this);\r\n                        }\r\n                        scheduled = false;\r\n                    });\r\n                }\r\n                // chained upstream computeds are notified synchronously to ensure\r\n                // value invalidation in case of sync access; normal effects are\r\n                // deferred to be triggered in scheduler.\r\n                for (const e of this.dep) {\r\n                    if (e.computed) {\r\n                        e.scheduler(true /* computedTrigger */);\r\n                    }\r\n                }\r\n            }\r\n            this._dirty = true;\r\n        });\r\n        this.effect.computed = true;\r\n    }\r\n    _get() {\r\n        if (this._dirty) {\r\n            this._dirty = false;\r\n            return (this._value = this.effect.run());\r\n        }\r\n        return this._value;\r\n    }\r\n    get value() {\r\n        trackRefValue(this);\r\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\r\n        return toRaw(this)._get();\r\n    }\r\n}\r\n_a = \"__v_isReadonly\" /* IS_READONLY */;\r\nfunction deferredComputed(getter) {\r\n    return new DeferredComputedRefImpl(getter);\r\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n"]},"metadata":{},"sourceType":"module"}