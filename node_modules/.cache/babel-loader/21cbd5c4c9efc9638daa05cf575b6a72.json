{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.array.splice.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.parse = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar domhandler_1 = require(\"domhandler\");\n\nvar parse5_1 = require(\"parse5\");\n\nvar parse5_htmlparser2_tree_adapter_1 = tslib_1.__importDefault(require(\"parse5-htmlparser2-tree-adapter\"));\n\nfunction parse(content, options, isDocument) {\n  var opts = {\n    scriptingEnabled: typeof options.scriptingEnabled === 'boolean' ? options.scriptingEnabled : true,\n    treeAdapter: parse5_htmlparser2_tree_adapter_1[\"default\"],\n    sourceCodeLocationInfo: options.sourceCodeLocationInfo\n  };\n  var context = options.context; // @ts-expect-error The tree adapter unfortunately doesn't return the exact types.\n\n  return isDocument ? parse5_1.parse(content, opts) : // @ts-expect-error Same issue again.\n  parse5_1.parseFragment(context, content, opts);\n}\n\nexports.parse = parse;\n\nfunction render(dom) {\n  var _a;\n  /*\n   * `dom-serializer` passes over the special \"root\" node and renders the\n   * node's children in its place. To mimic this behavior with `parse5`, an\n   * equivalent operation must be applied to the input array.\n   */\n\n\n  var nodes = 'length' in dom ? dom : [dom];\n\n  for (var index = 0; index < nodes.length; index += 1) {\n    var node = nodes[index];\n\n    if (domhandler_1.isDocument(node)) {\n      (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArray([nodes, index, 1], node.children));\n    }\n  } // @ts-expect-error Types don't align here either.\n\n\n  return parse5_1.serialize({\n    children: nodes\n  }, {\n    treeAdapter: parse5_htmlparser2_tree_adapter_1[\"default\"]\n  });\n}\n\nexports.render = render;","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/cheerio/lib/parsers/parse5-adapter.js"],"names":["Object","defineProperty","exports","value","render","parse","tslib_1","require","domhandler_1","parse5_1","parse5_htmlparser2_tree_adapter_1","__importDefault","content","options","isDocument","opts","scriptingEnabled","treeAdapter","sourceCodeLocationInfo","context","parseFragment","dom","_a","nodes","index","length","node","Array","prototype","splice","call","apply","__spreadArray","children","serialize"],"mappings":"AAAA;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,MAAR,GAAiBF,OAAO,CAACG,KAAR,GAAgB,KAAK,CAAtC;;AACA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AACA,IAAIC,YAAY,GAAGD,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAIG,iCAAiC,GAAGJ,OAAO,CAACK,eAAR,CAAwBJ,OAAO,CAAC,iCAAD,CAA/B,CAAxC;;AACA,SAASF,KAAT,CAAeO,OAAf,EAAwBC,OAAxB,EAAiCC,UAAjC,EAA6C;AACzC,MAAIC,IAAI,GAAG;AACPC,IAAAA,gBAAgB,EAAE,OAAOH,OAAO,CAACG,gBAAf,KAAoC,SAApC,GACZH,OAAO,CAACG,gBADI,GAEZ,IAHC;AAIPC,IAAAA,WAAW,EAAEP,iCAAiC,WAJvC;AAKPQ,IAAAA,sBAAsB,EAAEL,OAAO,CAACK;AALzB,GAAX;AAOA,MAAIC,OAAO,GAAGN,OAAO,CAACM,OAAtB,CARyC,CASzC;;AACA,SAAOL,UAAU,GACXL,QAAQ,CAACJ,KAAT,CAAeO,OAAf,EAAwBG,IAAxB,CADW,GAEX;AACEN,EAAAA,QAAQ,CAACW,aAAT,CAAuBD,OAAvB,EAAgCP,OAAhC,EAAyCG,IAAzC,CAHR;AAIH;;AACDb,OAAO,CAACG,KAAR,GAAgBA,KAAhB;;AACA,SAASD,MAAT,CAAgBiB,GAAhB,EAAqB;AACjB,MAAIC,EAAJ;AACA;AACJ;AACA;AACA;AACA;;;AACI,MAAIC,KAAK,GAAG,YAAYF,GAAZ,GAAkBA,GAAlB,GAAwB,CAACA,GAAD,CAApC;;AACA,OAAK,IAAIG,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGD,KAAK,CAACE,MAAlC,EAA0CD,KAAK,IAAI,CAAnD,EAAsD;AAClD,QAAIE,IAAI,GAAGH,KAAK,CAACC,KAAD,CAAhB;;AACA,QAAIhB,YAAY,CAACM,UAAb,CAAwBY,IAAxB,CAAJ,EAAmC;AAC/B,OAACJ,EAAE,GAAGK,KAAK,CAACC,SAAN,CAAgBC,MAAtB,EAA8BC,IAA9B,CAAmCC,KAAnC,CAAyCT,EAAzC,EAA6ChB,OAAO,CAAC0B,aAAR,CAAsB,CAACT,KAAD,EAAQC,KAAR,EAAe,CAAf,CAAtB,EAAyCE,IAAI,CAACO,QAA9C,CAA7C;AACH;AACJ,GAbgB,CAcjB;;;AACA,SAAOxB,QAAQ,CAACyB,SAAT,CAAmB;AAAED,IAAAA,QAAQ,EAAEV;AAAZ,GAAnB,EAAwC;AAAEN,IAAAA,WAAW,EAAEP,iCAAiC;AAAhD,GAAxC,CAAP;AACH;;AACDR,OAAO,CAACE,MAAR,GAAiBA,MAAjB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.render = exports.parse = void 0;\nvar tslib_1 = require(\"tslib\");\nvar domhandler_1 = require(\"domhandler\");\nvar parse5_1 = require(\"parse5\");\nvar parse5_htmlparser2_tree_adapter_1 = tslib_1.__importDefault(require(\"parse5-htmlparser2-tree-adapter\"));\nfunction parse(content, options, isDocument) {\n    var opts = {\n        scriptingEnabled: typeof options.scriptingEnabled === 'boolean'\n            ? options.scriptingEnabled\n            : true,\n        treeAdapter: parse5_htmlparser2_tree_adapter_1.default,\n        sourceCodeLocationInfo: options.sourceCodeLocationInfo,\n    };\n    var context = options.context;\n    // @ts-expect-error The tree adapter unfortunately doesn't return the exact types.\n    return isDocument\n        ? parse5_1.parse(content, opts)\n        : // @ts-expect-error Same issue again.\n            parse5_1.parseFragment(context, content, opts);\n}\nexports.parse = parse;\nfunction render(dom) {\n    var _a;\n    /*\n     * `dom-serializer` passes over the special \"root\" node and renders the\n     * node's children in its place. To mimic this behavior with `parse5`, an\n     * equivalent operation must be applied to the input array.\n     */\n    var nodes = 'length' in dom ? dom : [dom];\n    for (var index = 0; index < nodes.length; index += 1) {\n        var node = nodes[index];\n        if (domhandler_1.isDocument(node)) {\n            (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArray([nodes, index, 1], node.children));\n        }\n    }\n    // @ts-expect-error Types don't align here either.\n    return parse5_1.serialize({ children: nodes }, { treeAdapter: parse5_htmlparser2_tree_adapter_1.default });\n}\nexports.render = render;\n"]},"metadata":{},"sourceType":"script"}