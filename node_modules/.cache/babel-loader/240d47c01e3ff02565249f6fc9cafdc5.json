{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.array.slice.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nrequire(\"core-js/modules/es.array.filter.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.array.some.js\");\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\n\nvar boolbase_1 = require(\"boolbase\");\n\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\n\n\nexports.PLACEHOLDER_ELEMENT = {};\n\nfunction ensureIsTag(next, adapter) {\n  if (next === boolbase_1.falseFunc) return boolbase_1.falseFunc;\n  return function (elem) {\n    return adapter.isTag(elem) && next(elem);\n  };\n}\n\nexports.ensureIsTag = ensureIsTag;\n\nfunction getNextSiblings(elem, adapter) {\n  var siblings = adapter.getSiblings(elem);\n  if (siblings.length <= 1) return [];\n  var elemIndex = siblings.indexOf(elem);\n  if (elemIndex < 0 || elemIndex === siblings.length - 1) return [];\n  return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\n\nexports.getNextSiblings = getNextSiblings;\n\nvar is = function is(next, token, options, context, compileToken) {\n  var opts = {\n    xmlMode: !!options.xmlMode,\n    adapter: options.adapter,\n    equals: options.equals\n  };\n  var func = compileToken(token, opts, context);\n  return function (elem) {\n    return func(elem) && next(elem);\n  };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\n\n\nexports.subselects = {\n  is: is,\n\n  /**\n   * `:matches` and `:where` are aliases for `:is`.\n   */\n  matches: is,\n  where: is,\n  not: function not(next, token, options, context, compileToken) {\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      adapter: options.adapter,\n      equals: options.equals\n    };\n    var func = compileToken(token, opts, context);\n    if (func === boolbase_1.falseFunc) return next;\n    if (func === boolbase_1.trueFunc) return boolbase_1.falseFunc;\n    return function not(elem) {\n      return !func(elem) && next(elem);\n    };\n  },\n  has: function has(next, subselect, options, _context, compileToken) {\n    var adapter = options.adapter;\n    var opts = {\n      xmlMode: !!options.xmlMode,\n      adapter: adapter,\n      equals: options.equals\n    }; // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n\n    var context = subselect.some(function (s) {\n      return s.some(procedure_1.isTraversal);\n    }) ? [exports.PLACEHOLDER_ELEMENT] : undefined;\n    var compiled = compileToken(subselect, opts, context);\n    if (compiled === boolbase_1.falseFunc) return boolbase_1.falseFunc;\n\n    if (compiled === boolbase_1.trueFunc) {\n      return function (elem) {\n        return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n      };\n    }\n\n    var hasElement = ensureIsTag(compiled, adapter);\n    var _a = compiled.shouldTestNextSiblings,\n        shouldTestNextSiblings = _a === void 0 ? false : _a;\n    /*\n     * `shouldTestNextSiblings` will only be true if the query starts with\n     * a traversal (sibling or adjacent). That means we will always have a context.\n     */\n\n    if (context) {\n      return function (elem) {\n        context[0] = elem;\n        var childs = adapter.getChildren(elem);\n        var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;\n        return next(elem) && adapter.existsOne(hasElement, nextElements);\n      };\n    }\n\n    return function (elem) {\n      return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));\n    };\n  }\n};","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/css-select/lib/pseudo-selectors/subselects.js"],"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","Object","defineProperty","exports","value","subselects","getNextSiblings","ensureIsTag","PLACEHOLDER_ELEMENT","boolbase_1","require","procedure_1","next","adapter","falseFunc","elem","isTag","siblings","getSiblings","elemIndex","indexOf","filter","is","token","options","context","compileToken","opts","xmlMode","equals","func","matches","where","not","trueFunc","has","subselect","_context","some","s","isTraversal","undefined","compiled","getChildren","hasElement","_a","shouldTestNextSiblings","childs","nextElements","existsOne"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subselects = exports.getNextSiblings = exports.ensureIsTag = exports.PLACEHOLDER_ELEMENT = void 0;\nvar boolbase_1 = require(\"boolbase\");\nvar procedure_1 = require(\"../procedure\");\n/** Used as a placeholder for :has. Will be replaced with the actual element. */\nexports.PLACEHOLDER_ELEMENT = {};\nfunction ensureIsTag(next, adapter) {\n    if (next === boolbase_1.falseFunc)\n        return boolbase_1.falseFunc;\n    return function (elem) { return adapter.isTag(elem) && next(elem); };\n}\nexports.ensureIsTag = ensureIsTag;\nfunction getNextSiblings(elem, adapter) {\n    var siblings = adapter.getSiblings(elem);\n    if (siblings.length <= 1)\n        return [];\n    var elemIndex = siblings.indexOf(elem);\n    if (elemIndex < 0 || elemIndex === siblings.length - 1)\n        return [];\n    return siblings.slice(elemIndex + 1).filter(adapter.isTag);\n}\nexports.getNextSiblings = getNextSiblings;\nvar is = function (next, token, options, context, compileToken) {\n    var opts = {\n        xmlMode: !!options.xmlMode,\n        adapter: options.adapter,\n        equals: options.equals,\n    };\n    var func = compileToken(token, opts, context);\n    return function (elem) { return func(elem) && next(elem); };\n};\n/*\n * :not, :has, :is, :matches and :where have to compile selectors\n * doing this in src/pseudos.ts would lead to circular dependencies,\n * so we add them here\n */\nexports.subselects = {\n    is: is,\n    /**\n     * `:matches` and `:where` are aliases for `:is`.\n     */\n    matches: is,\n    where: is,\n    not: function (next, token, options, context, compileToken) {\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: options.adapter,\n            equals: options.equals,\n        };\n        var func = compileToken(token, opts, context);\n        if (func === boolbase_1.falseFunc)\n            return next;\n        if (func === boolbase_1.trueFunc)\n            return boolbase_1.falseFunc;\n        return function not(elem) {\n            return !func(elem) && next(elem);\n        };\n    },\n    has: function (next, subselect, options, _context, compileToken) {\n        var adapter = options.adapter;\n        var opts = {\n            xmlMode: !!options.xmlMode,\n            adapter: adapter,\n            equals: options.equals,\n        };\n        // @ts-expect-error Uses an array as a pointer to the current element (side effects)\n        var context = subselect.some(function (s) {\n            return s.some(procedure_1.isTraversal);\n        })\n            ? [exports.PLACEHOLDER_ELEMENT]\n            : undefined;\n        var compiled = compileToken(subselect, opts, context);\n        if (compiled === boolbase_1.falseFunc)\n            return boolbase_1.falseFunc;\n        if (compiled === boolbase_1.trueFunc) {\n            return function (elem) {\n                return adapter.getChildren(elem).some(adapter.isTag) && next(elem);\n            };\n        }\n        var hasElement = ensureIsTag(compiled, adapter);\n        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;\n        /*\n         * `shouldTestNextSiblings` will only be true if the query starts with\n         * a traversal (sibling or adjacent). That means we will always have a context.\n         */\n        if (context) {\n            return function (elem) {\n                context[0] = elem;\n                var childs = adapter.getChildren(elem);\n                var nextElements = shouldTestNextSiblings\n                    ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;\n                return (next(elem) && adapter.existsOne(hasElement, nextElements));\n            };\n        }\n        return function (elem) {\n            return next(elem) &&\n                adapter.existsOne(hasElement, adapter.getChildren(elem));\n        };\n    },\n};\n"]},"metadata":{},"sourceType":"script"}