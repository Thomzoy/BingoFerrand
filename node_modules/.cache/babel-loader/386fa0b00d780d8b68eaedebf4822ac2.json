{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/classCallCheck.js\")[\"default\"];\n\nvar _createClass = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/createClass.js\")[\"default\"];\n\nvar _inherits = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/inherits.js\")[\"default\"];\n\nvar _createSuper = require(\"/home/thomas/Code/BingoFerrand/node_modules/@babel/runtime/helpers/createSuper.js\")[\"default\"];\n\nrequire(\"core-js/modules/es.array.index-of.js\");\n\nvar Mixin = require('../../utils/mixin');\n\nvar Tokenizer = require('../../tokenizer');\n\nvar LocationInfoTokenizerMixin = require('./tokenizer-mixin');\n\nvar LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\n\nvar HTML = require('../../common/html'); //Aliases\n\n\nvar $ = HTML.TAG_NAMES;\n\nvar LocationInfoParserMixin = /*#__PURE__*/function (_Mixin) {\n  _inherits(LocationInfoParserMixin, _Mixin);\n\n  var _super = _createSuper(LocationInfoParserMixin);\n\n  function LocationInfoParserMixin(parser) {\n    var _this;\n\n    _classCallCheck(this, LocationInfoParserMixin);\n\n    _this = _super.call(this, parser);\n    _this.parser = parser;\n    _this.treeAdapter = _this.parser.treeAdapter;\n    _this.posTracker = null;\n    _this.lastStartTagToken = null;\n    _this.lastFosterParentingLocation = null;\n    _this.currentToken = null;\n    return _this;\n  }\n\n  _createClass(LocationInfoParserMixin, [{\n    key: \"_setStartLocation\",\n    value: function _setStartLocation(element) {\n      var loc = null;\n\n      if (this.lastStartTagToken) {\n        loc = Object.assign({}, this.lastStartTagToken.location);\n        loc.startTag = this.lastStartTagToken.location;\n      }\n\n      this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n  }, {\n    key: \"_setEndLocation\",\n    value: function _setEndLocation(element, closingToken) {\n      var loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n      if (loc) {\n        if (closingToken.location) {\n          var ctLoc = closingToken.location;\n          var tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n          // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n          var isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n          var endLoc = {};\n\n          if (isClosingEndTag) {\n            endLoc.endTag = Object.assign({}, ctLoc);\n            endLoc.endLine = ctLoc.endLine;\n            endLoc.endCol = ctLoc.endCol;\n            endLoc.endOffset = ctLoc.endOffset;\n          } else {\n            endLoc.endLine = ctLoc.startLine;\n            endLoc.endCol = ctLoc.startCol;\n            endLoc.endOffset = ctLoc.startOffset;\n          }\n\n          this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n        }\n      }\n    }\n  }, {\n    key: \"_getOverriddenMethods\",\n    value: function _getOverriddenMethods(mxn, orig) {\n      return {\n        _bootstrap: function _bootstrap(document, fragmentContext) {\n          orig._bootstrap.call(this, document, fragmentContext);\n\n          mxn.lastStartTagToken = null;\n          mxn.lastFosterParentingLocation = null;\n          mxn.currentToken = null;\n          var tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n          mxn.posTracker = tokenizerMixin.posTracker;\n          Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n            onItemPop: function onItemPop(element) {\n              mxn._setEndLocation(element, mxn.currentToken);\n            }\n          });\n        },\n        _runParsingLoop: function _runParsingLoop(scriptHandler) {\n          orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n          // that remains on open element stack\n\n\n          for (var i = this.openElements.stackTop; i >= 0; i--) {\n            mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n          }\n        },\n        //Token processing\n        _processTokenInForeignContent: function _processTokenInForeignContent(token) {\n          mxn.currentToken = token;\n\n          orig._processTokenInForeignContent.call(this, token);\n        },\n        _processToken: function _processToken(token) {\n          mxn.currentToken = token;\n\n          orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n          //their end location explicitly.\n\n\n          var requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n          if (requireExplicitUpdate) {\n            for (var i = this.openElements.stackTop; i >= 0; i--) {\n              var element = this.openElements.items[i];\n\n              if (this.treeAdapter.getTagName(element) === token.tagName) {\n                mxn._setEndLocation(element, token);\n\n                break;\n              }\n            }\n          }\n        },\n        //Doctype\n        _setDocumentType: function _setDocumentType(token) {\n          orig._setDocumentType.call(this, token);\n\n          var documentChildren = this.treeAdapter.getChildNodes(this.document);\n          var cnLength = documentChildren.length;\n\n          for (var i = 0; i < cnLength; i++) {\n            var node = documentChildren[i];\n\n            if (this.treeAdapter.isDocumentTypeNode(node)) {\n              this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n              break;\n            }\n          }\n        },\n        //Elements\n        _attachElementToTree: function _attachElementToTree(element) {\n          //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n          //So we will use token location stored in this methods for the element.\n          mxn._setStartLocation(element);\n\n          mxn.lastStartTagToken = null;\n\n          orig._attachElementToTree.call(this, element);\n        },\n        _appendElement: function _appendElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._appendElement.call(this, token, namespaceURI);\n        },\n        _insertElement: function _insertElement(token, namespaceURI) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertElement.call(this, token, namespaceURI);\n        },\n        _insertTemplate: function _insertTemplate(token) {\n          mxn.lastStartTagToken = token;\n\n          orig._insertTemplate.call(this, token);\n\n          var tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n          this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n        },\n        _insertFakeRootElement: function _insertFakeRootElement() {\n          orig._insertFakeRootElement.call(this);\n\n          this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n        },\n        //Comments\n        _appendCommentNode: function _appendCommentNode(token, parent) {\n          orig._appendCommentNode.call(this, token, parent);\n\n          var children = this.treeAdapter.getChildNodes(parent);\n          var commentNode = children[children.length - 1];\n          this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n        },\n        //Text\n        _findFosterParentingLocation: function _findFosterParentingLocation() {\n          //NOTE: store last foster parenting location, so we will be able to find inserted text\n          //in case of foster parenting\n          mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n          return mxn.lastFosterParentingLocation;\n        },\n        _insertCharacters: function _insertCharacters(token) {\n          orig._insertCharacters.call(this, token);\n\n          var hasFosterParent = this._shouldFosterParentOnInsertion();\n\n          var parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n          var siblings = this.treeAdapter.getChildNodes(parent);\n          var textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n          var textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n          var tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n          if (tnLoc) {\n            var _token$location = token.location,\n                endLine = _token$location.endLine,\n                endCol = _token$location.endCol,\n                endOffset = _token$location.endOffset;\n            this.treeAdapter.updateNodeSourceCodeLocation(textNode, {\n              endLine: endLine,\n              endCol: endCol,\n              endOffset: endOffset\n            });\n          } else {\n            this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n          }\n        }\n      };\n    }\n  }]);\n\n  return LocationInfoParserMixin;\n}(Mixin);\n\nmodule.exports = LocationInfoParserMixin;","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/cheerio/node_modules/parse5/lib/extensions/location-info/parser-mixin.js"],"names":["Mixin","require","Tokenizer","LocationInfoTokenizerMixin","LocationInfoOpenElementStackMixin","HTML","$","TAG_NAMES","LocationInfoParserMixin","parser","treeAdapter","posTracker","lastStartTagToken","lastFosterParentingLocation","currentToken","element","loc","Object","assign","location","startTag","setNodeSourceCodeLocation","closingToken","getNodeSourceCodeLocation","ctLoc","tn","getTagName","isClosingEndTag","type","END_TAG_TOKEN","tagName","endLoc","endTag","endLine","endCol","endOffset","startLine","startCol","startOffset","updateNodeSourceCodeLocation","mxn","orig","_bootstrap","document","fragmentContext","call","tokenizerMixin","install","tokenizer","openElements","onItemPop","_setEndLocation","_runParsingLoop","scriptHandler","i","stackTop","items","_processTokenInForeignContent","token","_processToken","requireExplicitUpdate","BODY","hasInScope","_setDocumentType","documentChildren","getChildNodes","cnLength","length","node","isDocumentTypeNode","_attachElementToTree","_setStartLocation","_appendElement","namespaceURI","_insertElement","_insertTemplate","tmplContent","getTemplateContent","current","_insertFakeRootElement","_appendCommentNode","parent","children","commentNode","_findFosterParentingLocation","_insertCharacters","hasFosterParent","_shouldFosterParentOnInsertion","currentTmplContent","siblings","textNodeIdx","beforeElement","indexOf","textNode","tnLoc","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Mixin = require('../../utils/mixin');\nconst Tokenizer = require('../../tokenizer');\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\nconst HTML = require('../../common/html');\n\n//Aliases\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n    constructor(parser) {\n        super(parser);\n\n        this.parser = parser;\n        this.treeAdapter = this.parser.treeAdapter;\n        this.posTracker = null;\n        this.lastStartTagToken = null;\n        this.lastFosterParentingLocation = null;\n        this.currentToken = null;\n    }\n\n    _setStartLocation(element) {\n        let loc = null;\n\n        if (this.lastStartTagToken) {\n            loc = Object.assign({}, this.lastStartTagToken.location);\n            loc.startTag = this.lastStartTagToken.location;\n        }\n\n        this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n    }\n\n    _setEndLocation(element, closingToken) {\n        const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n        if (loc) {\n            if (closingToken.location) {\n                const ctLoc = closingToken.location;\n                const tn = this.treeAdapter.getTagName(element);\n\n                // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n                // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n                const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n                const endLoc = {};\n                if (isClosingEndTag) {\n                    endLoc.endTag = Object.assign({}, ctLoc);\n                    endLoc.endLine = ctLoc.endLine;\n                    endLoc.endCol = ctLoc.endCol;\n                    endLoc.endOffset = ctLoc.endOffset;\n                } else {\n                    endLoc.endLine = ctLoc.startLine;\n                    endLoc.endCol = ctLoc.startCol;\n                    endLoc.endOffset = ctLoc.startOffset;\n                }\n\n                this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n            }\n        }\n    }\n\n    _getOverriddenMethods(mxn, orig) {\n        return {\n            _bootstrap(document, fragmentContext) {\n                orig._bootstrap.call(this, document, fragmentContext);\n\n                mxn.lastStartTagToken = null;\n                mxn.lastFosterParentingLocation = null;\n                mxn.currentToken = null;\n\n                const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n\n                mxn.posTracker = tokenizerMixin.posTracker;\n\n                Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n                    onItemPop: function(element) {\n                        mxn._setEndLocation(element, mxn.currentToken);\n                    }\n                });\n            },\n\n            _runParsingLoop(scriptHandler) {\n                orig._runParsingLoop.call(this, scriptHandler);\n\n                // NOTE: generate location info for elements\n                // that remains on open element stack\n                for (let i = this.openElements.stackTop; i >= 0; i--) {\n                    mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n                }\n            },\n\n            //Token processing\n            _processTokenInForeignContent(token) {\n                mxn.currentToken = token;\n                orig._processTokenInForeignContent.call(this, token);\n            },\n\n            _processToken(token) {\n                mxn.currentToken = token;\n                orig._processToken.call(this, token);\n\n                //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n                //their end location explicitly.\n                const requireExplicitUpdate =\n                    token.type === Tokenizer.END_TAG_TOKEN &&\n                    (token.tagName === $.HTML || (token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));\n\n                if (requireExplicitUpdate) {\n                    for (let i = this.openElements.stackTop; i >= 0; i--) {\n                        const element = this.openElements.items[i];\n\n                        if (this.treeAdapter.getTagName(element) === token.tagName) {\n                            mxn._setEndLocation(element, token);\n                            break;\n                        }\n                    }\n                }\n            },\n\n            //Doctype\n            _setDocumentType(token) {\n                orig._setDocumentType.call(this, token);\n\n                const documentChildren = this.treeAdapter.getChildNodes(this.document);\n                const cnLength = documentChildren.length;\n\n                for (let i = 0; i < cnLength; i++) {\n                    const node = documentChildren[i];\n\n                    if (this.treeAdapter.isDocumentTypeNode(node)) {\n                        this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n                        break;\n                    }\n                }\n            },\n\n            //Elements\n            _attachElementToTree(element) {\n                //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n                //So we will use token location stored in this methods for the element.\n                mxn._setStartLocation(element);\n                mxn.lastStartTagToken = null;\n                orig._attachElementToTree.call(this, element);\n            },\n\n            _appendElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._appendElement.call(this, token, namespaceURI);\n            },\n\n            _insertElement(token, namespaceURI) {\n                mxn.lastStartTagToken = token;\n                orig._insertElement.call(this, token, namespaceURI);\n            },\n\n            _insertTemplate(token) {\n                mxn.lastStartTagToken = token;\n                orig._insertTemplate.call(this, token);\n\n                const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n\n                this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n            },\n\n            _insertFakeRootElement() {\n                orig._insertFakeRootElement.call(this);\n                this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n            },\n\n            //Comments\n            _appendCommentNode(token, parent) {\n                orig._appendCommentNode.call(this, token, parent);\n\n                const children = this.treeAdapter.getChildNodes(parent);\n                const commentNode = children[children.length - 1];\n\n                this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n            },\n\n            //Text\n            _findFosterParentingLocation() {\n                //NOTE: store last foster parenting location, so we will be able to find inserted text\n                //in case of foster parenting\n                mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n\n                return mxn.lastFosterParentingLocation;\n            },\n\n            _insertCharacters(token) {\n                orig._insertCharacters.call(this, token);\n\n                const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n                const parent =\n                    (hasFosterParent && mxn.lastFosterParentingLocation.parent) ||\n                    this.openElements.currentTmplContent ||\n                    this.openElements.current;\n\n                const siblings = this.treeAdapter.getChildNodes(parent);\n\n                const textNodeIdx =\n                    hasFosterParent && mxn.lastFosterParentingLocation.beforeElement\n                        ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1\n                        : siblings.length - 1;\n\n                const textNode = siblings[textNodeIdx];\n\n                //NOTE: if we have location assigned by another token, then just update end position\n                const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n                if (tnLoc) {\n                    const { endLine, endCol, endOffset } = token.location;\n                    this.treeAdapter.updateNodeSourceCodeLocation(textNode, { endLine, endCol, endOffset });\n                } else {\n                    this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n                }\n            }\n        };\n    }\n}\n\nmodule.exports = LocationInfoParserMixin;\n"]},"metadata":{},"sourceType":"script"}