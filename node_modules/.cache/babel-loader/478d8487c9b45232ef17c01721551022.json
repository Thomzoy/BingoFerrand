{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.object.define-property.js\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compile = void 0;\n\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\n\n\nfunction compile(parsed) {\n  var a = parsed[0]; // Subtract 1 from `b`, to convert from one- to zero-indexed.\n\n  var b = parsed[1] - 1;\n  /*\n   * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n   * Besides, the specification states that no elements are\n   * matched when `a` and `b` are 0.\n   *\n   * `b < 0` here as we subtracted 1 from `b` above.\n   */\n\n  if (b < 0 && a <= 0) return boolbase_1.falseFunc; // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n\n  if (a === -1) return function (index) {\n    return index <= b;\n  };\n  if (a === 0) return function (index) {\n    return index === b;\n  }; // When `b <= 0` and `a === 1`, they match any element.\n\n  if (a === 1) return b < 0 ? boolbase_1.trueFunc : function (index) {\n    return index >= b;\n  };\n  /*\n   * Otherwise, modulo can be used to check if there is a match.\n   *\n   * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n   */\n\n  var absA = Math.abs(a); // Get `b mod a`, + a if this is negative.\n\n  var bMod = (b % absA + absA) % absA;\n  return a > 1 ? function (index) {\n    return index >= b && index % absA === bMod;\n  } : function (index) {\n    return index <= b && index % absA === bMod;\n  };\n}\n\nexports.compile = compile;","map":{"version":3,"sources":["/home/thomas/Code/BingoFerrand/node_modules/nth-check/lib/compile.js"],"names":["Object","defineProperty","exports","value","compile","boolbase_1","require","parsed","a","b","falseFunc","index","trueFunc","absA","Math","abs","bMod"],"mappings":"AAAA;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AACA,IAAIC,UAAU,GAAGC,OAAO,CAAC,UAAD,CAAxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASF,OAAT,CAAiBG,MAAjB,EAAyB;AACrB,MAAIC,CAAC,GAAGD,MAAM,CAAC,CAAD,CAAd,CADqB,CAErB;;AACA,MAAIE,CAAC,GAAGF,MAAM,CAAC,CAAD,CAAN,GAAY,CAApB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI,MAAIE,CAAC,GAAG,CAAJ,IAASD,CAAC,IAAI,CAAlB,EACI,OAAOH,UAAU,CAACK,SAAlB,CAZiB,CAarB;;AACA,MAAIF,CAAC,KAAK,CAAC,CAAX,EACI,OAAO,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAhB;AAAoB,GAA9C;AACJ,MAAID,CAAC,KAAK,CAAV,EACI,OAAO,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,KAAKF,CAAjB;AAAqB,GAA/C,CAjBiB,CAkBrB;;AACA,MAAID,CAAC,KAAK,CAAV,EACI,OAAOC,CAAC,GAAG,CAAJ,GAAQJ,UAAU,CAACO,QAAnB,GAA8B,UAAUD,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAhB;AAAoB,GAA5E;AACJ;AACJ;AACA;AACA;AACA;;AACI,MAAII,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASP,CAAT,CAAX,CA1BqB,CA2BrB;;AACA,MAAIQ,IAAI,GAAG,CAAEP,CAAC,GAAGI,IAAL,GAAaA,IAAd,IAAsBA,IAAjC;AACA,SAAOL,CAAC,GAAG,CAAJ,GACD,UAAUG,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;AAA6C,GAD/D,GAED,UAAUL,KAAV,EAAiB;AAAE,WAAOA,KAAK,IAAIF,CAAT,IAAcE,KAAK,GAAGE,IAAR,KAAiBG,IAAtC;AAA6C,GAFtE;AAGH;;AACDd,OAAO,CAACE,OAAR,GAAkBA,OAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = void 0;\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n"]},"metadata":{},"sourceType":"script"}